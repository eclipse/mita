/* XPECT_SETUP org.eclipse.mita.program.tests.strings.StringsTest 
Workspace {
	Project "testproject" {
	}  
}
END_SETUP */

package test;
import platforms.unittest;

// Strings are one-byte ASCII strings (not UTF8, not ISO8859-1)
// Strings have a maximum length fixed at compile time

function someExternalFunction() : int32 {
	return 5;
}

// XPECT noCompileErrors
function stringTestSuccess() : void {
	// XPECT inferredType --> string<14>
	var bar = "this is a test";

	// XPECT inferredType --> string<24>
	var foo = "hello world";
	foo = "this is my long sentence"; // This is ok. At compile time we can determine that foo is max 24 characters.
	
	// The length of a string can be set explicitly
	// XPECT inferredType --> string<300>
	// XPECT infos --> "_ has type '300" at "_"
	var foo2 : string<_> = new string<300>();
	foo2 = "bla";
	
	// Strings with explicit size can be used in loops
	var explicitSize = new string<300>();
	for(var i: uint8 = 0; i < 10; i+=1) {
		explicitSize += "foo";
	} 
	
	// Strings can be concatenated using +
	// XPECT inferredType --> string<18>
	var foo3 = "bla bla";
	foo3 += "hello world";

	// Strings can be interpolated
	let bla = 42;
	let greeting = "good sir";
	// XPECT inferredType --> string<30>
	let baz = `my variable: ${bla} and ${greeting}`;
	
	let x10 = `${bla}`;
	let x11 = `xx ${bla}`;
	let x12 = `${bla} xx`;
	let x13 = ``;
	let x14 = `foo`;
	let x15 = `foo\n`;
	let x16 = `${x14}${x15}`;
	let x17 = `${x14} ${x15}`;
	let x18 = `\n\t\r 0123456789{}()[],.;:`;
	let x19 = `{ } , ; : . ( ) [ ] + - * / % \\ && || & | = == < > <= >= !=`;
	let x20 = `alias-of alt alternative as catch checked constructor do else enum every exception export extends finally fn for function generated generator header hour hours if in import is isother let millisecond milliseconds minute minutes native native-type new package return second seconds setup size-inferrer static struct subtype-of throw try type unchecked validator var where while`;
	let x21 = `this ${"is"} a test`;
	let x22 = `${bla + bla * 2}`;
}

function stringTestFail() : void {
// XPECT inferredType --> string<A>
	var foo = "hello world";
	for(var i: uint16 = 0; i < someExternalFunction(); i=i++) { //TODO: Increment Operator i++
		// XPECT errors --> "Cannot determine size of element: Cannot infer string length in loops" at "foo += "hello""
		foo += "hello"; // compiler error: Cannot determine the length of foo. Please set the length explicitly.
	}
}
function notSupportedArrayUsage(): void {
	/* XPECT errors ---
		"Cannot determine size of element: Cannot infer string length of s»"hello world"" at ""hello world""
		"prim»s»"hello world" (:: string) has a different type than foo (:: array<A>)" at ""hello world""
	--- */
	var foo = "hello world";
	// We don't support direct access yet
	// XPECT errors --> "Cannot determine size of element: Unable to infer size from type A" at "foo[1]"
	var bar = foo[1];
	// the error that is produced here manifests at `var foo`: 
	// [1:3] creates the very strong type constraint that foo :: array<T>.
	// The solver therefore sees the problem in initializing foo with a string.
	var bar2 = foo[1:3];
}

