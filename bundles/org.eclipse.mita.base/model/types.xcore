@GenModel(copyrightText="generated by Xtext 2.13.0", operationReflection="false", modelDirectory="/org.eclipse.mita.base/emf-gen")
package org.eclipse.mita.base.types

/********************************************************************************
 * Copyright (c) 2017, 2018 Bosch Connected Devices and Solutions GmbH.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * Contributors:
 *    Bosch Connected Devices and Solutions GmbH - initial contribution
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/

import java.util.HashSet
import java.util.Set
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.mita.base.util.BaseUtils
import org.eclipse.emf.ecore.EObject
import org.eclipse.mita.base.expressions.Literal

class InterpolatedStringLiteral extends Literal {
	String[] text
	contains Expression[] content
}

class TypeSpecifier {}
class PresentTypeSpecifier extends TypeSpecifier {
	refers Type ^type
	contains PresentTypeSpecifier[] typeArguments
	
	boolean optional
	String[] referenceModifiers
	
	op String toString() {
		val args = if(typeArguments.empty) {
			""
		} else {
			"<" + typeArguments.map[if(it === null) {"null"} else {it.toString}].reduce[p1, p2| p1 + ", " + p2] + ">"
		}

		val ref = eGet(TypesPackage.eINSTANCE.presentTypeSpecifier_Type, false)
		var refText = if (ref instanceof EObject && !(ref as EObject).eIsProxy) ref?.toString else null
		refText = refText ?: BaseUtils.getText(this, TypesPackage.eINSTANCE.presentTypeSpecifier_Type)
		refText = refText ?: ""
		refText = refText.trim
		
		return refText + args;
	}
}

class NullTypeSpecifier extends TypeSpecifier {
	op String toString() {
		return "NullTypeSpecifier";
	}
}

abstract class NamedElement {
	String name
}
abstract class PackageMember extends NamedElement {
	derived id String ^id get {
		return BaseUtils.computeQID(this);
	}
}
class Package extends PackageMember {
	contains PackageMember[] member
	refers Package[] ^import
}
abstract class Type extends PackageMember {
	boolean ^abstract
	op Type getOriginType() {
		return this;
	}
	
	contains TypeConstraint[] constraint
	contains TypeKind typeKind opposite kindOf
	
	op String toString() {
		return name;
	}
}
class TypeConstraint {
	Object value
}
class TypeKind extends Type {
	op String getName() {
		return "∗" + kindOf?.name
	}
	op String toString() {
		return "∗" + kindOf?.name
	}
	container Type kindOf opposite typeKind
}
class PrimitiveType extends Type, Exportable {
	op String toString() {
		return super.toString();
	}
}

interface GeneratedObject {
	op void generateMembers()
}
class VirtualFunction extends Operation, GeneratedObject { /* stub for now */
	op void generateMembers() {
		/* stub */
	}
}

class TypeAccessor extends VirtualFunction {
	op void generateMembers() {
		super.generateMembers();
		if(generatedParameter === null) {
			generatedParameter = TypesFactory.eINSTANCE.createParameter => [
				it.typeSpecifier = TypesFactory.eINSTANCE.createPresentTypeSpecifier;
				it.name = "self";
			]
		}
		if((generatedParameter.typeSpecifier as PresentTypeSpecifier).^type === null) {
			(generatedParameter.typeSpecifier as PresentTypeSpecifier).^type = accessedFeature.structuralType;
		} 
	}
	
	op StructuralParameter getAccessedFeature() {
		val f = eContainer;
		if(f instanceof StructuralParameter) {
			return f;
		}
		return null;
	}
	op String getName() {
		return accessedFeature.name;
	}
	
	contains transient Parameter generatedParameter
	op Parameter[] getParameters() {
		generateMembers();
		return #[generatedParameter].asEList;
	}
	contains transient PresentTypeSpecifier generatedTypeSpecifier
	op TypeSpecifier getTypeSpecifier() {
		return accessedFeature.typeSpecifier;
	}
	op TypeParameter[] getTypeParameters() {
		return accessedFeature.structuralType.typeParameters;
	}
}
class StructuralParameter extends Parameter {
	op StructuralType getStructuralType() {
		val st = eContainer;
		if(st instanceof StructuralType) {
			return st;
		}
	}
	contains TypeAccessor accessor
}

class TypeConstructor extends VirtualFunction {
	
	op StructuralType getConstructedType() {
		return this.eContainer as StructuralType;
	}
	
	op void generateMembers() {
		super.generateMembers();
		if(generatedTypeSpecifier === null) {
			generatedTypeSpecifier = TypesFactory.eINSTANCE.createPresentTypeSpecifier => [ ts |
				ts.^type = constructedType;
				ts.typeArguments += BaseUtils.force(constructedType.typeParameters.map[ tp |
					TypesFactory.eINSTANCE.createPresentTypeSpecifier => [
						it.^type = tp
					]
				])
			]
		}
		if(generatedTypeSpecifier.^type === null) {
			generatedTypeSpecifier.^type = constructedType;
		}
		if(generatedTypeSpecifier.typeArguments.exists[it.^type === null]) {
			BaseUtils.zip(generatedTypeSpecifier.typeArguments, constructedType.typeParameters).forEach[ ta_tp |
				ta_tp.key.^type = ta_tp.value
			]	
		}
	}
	op String getName() {
		return constructedType.name;
	}
	op Parameter[] getParameters() {
		return constructedType.parameters.map[it as Parameter];
	} 
	contains transient PresentTypeSpecifier generatedTypeSpecifier
	op TypeSpecifier getTypeSpecifier() {
		generateMembers();
		return generatedTypeSpecifier;
	}
	op TypeParameter[] getTypeParameters() {
		return constructedType.typeParameters;
	}
}

class AnonymousProductTypeImportingConstructor extends SumSubTypeConstructor {
	op Parameter[] getParameters() {
		generateMembers();
		val anonymousProductType = constructedType as AnonymousProductType;
		// sadly this doesn't work since types aren't linked for some reason
		val realType = anonymousProductType.typeSpecifiers.head?.^type;
		if(realType instanceof StructuralType) {
			return (#[sumTypeParameter] + realType.constructor.parameters).toEList;
		}
		return anonymousProductType.constructor.parameters;
	}
}

class SumSubTypeConstructor extends TypeConstructor {
	contains transient Parameter sumTypeParameter
	
	op void generateMembers() {
		if(sumTypeParameter === null) {
			sumTypeParameter = TypesFactory.eINSTANCE.createParameter => [ p | 
				p.name = "self";
				p.typeSpecifier = TypesFactory.eINSTANCE.createPresentTypeSpecifier => [ ts |
					ts.^type = (this.eContainer.eContainer as SumType).typeKind;
				]
			]
		}
		if((sumTypeParameter.typeSpecifier as PresentTypeSpecifier).^type === null) {
			(sumTypeParameter.typeSpecifier as PresentTypeSpecifier).^type = (this.eContainer.eContainer as SumType).typeKind;
		}
		super.generateMembers();
	}
	op Parameter[] getParameters() {
		generateMembers();
		return (#[sumTypeParameter] + constructedType.parameters).toEList;
	} 
}
class ComplexType extends Type, GenericElement {
	contains Declaration[] features
	
	
	op Declaration[] getAllFeatures() {
		val features = new BasicEList<Declaration>();
		collectFeatures(this, features, new HashSet<Type>());
		return features;
	}
	
	op void collectFeatures(Type tpe, Declaration[] features, Object _visited) {
		val visited = _visited as Set<Type>;
		if (tpe === null || visited.contains(tpe))
			return;
		if (tpe instanceof ComplexType) {
			features.addAll(tpe.getFeatures());
		}
		visited.add(tpe);
	}
}
class StructuralType extends ComplexType {
	contains StructuralParameter[] parameters
	contains TypeConstructor constructor
}

class GenericElement extends NamedElement {
	contains TypeParameter[] typeParameters
}
class TypeParameter extends Type {
	refers Type bound
}
class Declaration extends TypedElement, NamedElement, PackageMember {
	op String toString() {
		return name + if(typeSpecifier instanceof org.eclipse.mita.base.types.PresentTypeSpecifier) ": " + typeSpecifier else ""
	}
}
abstract class TypedElement {
	contains TypeSpecifier typeSpecifier
	
	op Type getType() {
		if (getTypeSpecifier() instanceof PresentTypeSpecifier) {
			return (getTypeSpecifier() as PresentTypeSpecifier).getType();
		}
		return null;
	}
}

class Operation extends Declaration, GenericElement {
	contains Parameter[] parameters
	
	op String toString() {
		val typeParameterString = if(typeParameters.empty) {
			""
		} 
		else {
			"<" + typeParameters.join(", ") + ">"
		}
		val parameterString = parameters.toString
		return name + typeParameterString + "(" + parameterString + ")"
	}
}
class Parameter extends TypedElement, NamedElement {
	boolean optional
	
	op String toString() {
		val optionalModifier = if(optional) {
			"?"
		}
		else {
			""
		}
		return name + ": " + typeSpecifier
	}
}

abstract class Expression {
}
class ParameterWithDefaultValue extends Parameter {
	contains Expression defaultValue
}




class Enumerator extends Declaration {
	container EnumerationType owningEnumeration opposite enumerator
}
class EnumerationType extends PrimitiveType {
	contains Enumerator[] enumerator opposite owningEnumeration
	op String toString() {
		return super.toString()
	}
}

abstract class GeneratedElement {
	/**
	 * The fully-qualified class name of the generator class. 
	 */
	String generator
	
	/**
	 * The optional fully-qualified name of the validator class.
	 */
	String validator
	
	/**
	 * The optional fully-qualified name of the element size inferrer class.
	 */
	String sizeInferrer
}


interface HasAccessors {
	/**
	 * caution: this is only the type from the parsed model, not neccessarily the inferred type. Use with caution for type inferrence.
	 */
	op PresentTypeSpecifier[] accessorsTypes()
}

class Exportable {
	boolean exported
}

class ExceptionTypeDeclaration extends Type, Exportable {
}

class NativeType extends PrimitiveType, Exportable {
	String aliasOf
	String header
	
	op String getCName() {
		if(aliasOf === null) {
			return name
		} else {
			return aliasOf
		}
	}
	
	op String toString() {
		return name
	}
}

class StructureType extends StructuralType, HasAccessors, Exportable {
	op PresentTypeSpecifier[] accessorsTypes() {
		return parameters.map[it.typeSpecifier].filter(PresentTypeSpecifier).toEList;
	}
	
	op String toString() {
		super.toString
	}
}

class GeneratedType extends ComplexType, GeneratedElement, Exportable {	
	op String toString() {
		super.toString
	}
	contains Operation constructor
}

class GeneratedTypeConstructor extends Operation, GeneratedObject {
	contains transient PresentTypeSpecifier generatedTypeSpecifier
	
	op String getName() {
		val generatedType = if(eContainer instanceof GeneratedType) {
			eContainer as GeneratedType;
		} 
		else {
			null;
		}
		return "con_" + generatedType?.name
	}
	
	op TypeParameter[] getTypeParameters() {
		return (eContainer as GeneratedType).typeParameters;
	}
	op void generateMembers() {
		val generatedType = if(eContainer instanceof GeneratedType) {
			eContainer as GeneratedType;
		} 
		else {
			null;
		}
		if(generatedTypeSpecifier === null) {
			generatedTypeSpecifier = TypesFactory.eINSTANCE.createPresentTypeSpecifier => [ ts |
				ts.^type = generatedType;
				ts.typeArguments += BaseUtils.force(generatedType.typeParameters.map[ tp |
					TypesFactory.eINSTANCE.createPresentTypeSpecifier => [
						it.^type = tp
					]
				])
			]
		}
		if(generatedTypeSpecifier.^type === null) {
			generatedTypeSpecifier.^type = generatedType;
		}
		if(generatedTypeSpecifier.typeArguments.exists[it.^type === null]) {
			BaseUtils.zip(generatedTypeSpecifier.typeArguments, generatedType.typeParameters).forEach[ ta_tp |
				ta_tp.key.^type = ta_tp.value
			]	
		}
	}
	op TypeSpecifier getTypeSpecifier() {
		generateMembers();
		return generatedTypeSpecifier;
	}
}

class PackageAssociation {
	String name
	contains Type[] types
}

class ImportStatement {
	String importedNamespace
}
 

class SumType extends ComplexType, Exportable {
	// I would use features, but if I want to have SumAlternative as a ComplexType (which it is), then I can't make it a Declaration as well
	contains SumAlternative[] alternatives opposite sumType

	op String toString() {
		return super.toString();
	}
}

class SumAlternative extends StructuralType, GeneratedObject, HasAccessors {
	container SumType sumType opposite alternatives
	
	op Type realType() {
		return this;
	}
	
	op void generateMembers() {
	}
}
class Singleton extends SumAlternative {
	op PresentTypeSpecifier[] accessorsTypes() {
		return #[].asEList;
	}
}

class AnonymousStructuralParameter extends StructuralParameter {
	refers transient TypeSpecifier memberTypeSpecifier
	
	op TypeSpecifier getTypeSpecifier() {
		return memberTypeSpecifier;
	}
}
class AnonymousProductType extends SumAlternative {
	contains PresentTypeSpecifier[] typeSpecifiers 
	//contains transient AnonymousProductTypeImportingConstructor importingConstructor
	
	op void generateMembers() {
		super.generateMembers();
		if(generatedParameters.empty) {
			generatedParameters.clear;
			generatedParameters += BaseUtils.force(typeSpecifiers.indexed.map[ i_ts |
				val name = "_" + i_ts.key;
				val ts = i_ts.value;
				return TypesFactory.eINSTANCE.createAnonymousStructuralParameter() => [ p |
					p.name = name;
					p.memberTypeSpecifier = ts;
					p.accessor = TypesFactory.eINSTANCE.createTypeAccessor();
				];
			])
		}
	}
	op PresentTypeSpecifier[] accessorsTypes() {
		return typeSpecifiers;
	}
	contains transient StructuralParameter[] generatedParameters
	op StructuralParameter[] getParameters() {
		generateMembers();
		return generatedParameters;
	}
}
class NamedProductType extends SumAlternative, HasAccessors {
	// always return parameter types, since we never embed
	op PresentTypeSpecifier[] accessorsTypes() {
		return parameters.map[it.typeSpecifier].filter(PresentTypeSpecifier).toEList;
	}
}

class ProductMember extends StructuralParameter { }

class TypeAlias extends Type, Declaration {
	
	op Type getOriginType() {
		val baseType = getType();
		if (baseType instanceof TypeAlias && baseType != this) {
			return baseType.getOriginType();			
		}
		return baseType;
	}
	
}

class Property extends Declaration {
	boolean const
	boolean external
	boolean ^readonly
	op String toString() {
		return super.toString();
	}
}

class Event extends Declaration {
	
}

class CoercionExpression extends Expression {
	contains Expression value
	Object typeSpecifier
	op String toString() {
		return "((" + typeSpecifier + ") " + value + ")" 
	}
}

