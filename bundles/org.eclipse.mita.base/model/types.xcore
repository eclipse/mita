@GenModel(copyrightText="generated by Xtext 2.13.0", operationReflection="false", modelDirectory="/org.eclipse.mita.base/emf-gen")
package org.eclipse.mita.base.types

/********************************************************************************
 * Copyright (c) 2017, 2018 Bosch Connected Devices and Solutions GmbH.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * Contributors:
 *    Bosch Connected Devices and Solutions GmbH - initial contribution
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
 
import java.util.HashSet
import java.util.Set
import org.eclipse.emf.common.util.BasicEList

class TypeSpecifier {
	refers Type ^type
	contains TypeSpecifier[] typeArguments
	
	transient boolean optional
	transient String[] referenceModifiers
	
	op String toString() {
		val args = if(typeArguments.empty) {
			""
		} else {
			"<" + typeArguments.map[if(it === null) {"null"} else {it.toString}].reduce[p1, p2| p1 + ", " + p2] + ">"
		}
		val typeName = if(^type === null) {
			"null"
		} else {
			^type.toString
		}
		return typeName + args;
	}
}

abstract class NamedElement {
	String name
}
abstract class PackageMember extends NamedElement {
	derived id String ^id get {
		return TypesUtil.computeQID(this);
	}
}
class Package extends PackageMember {
	contains PackageMember[] member
	refers Package[] ^import
}
abstract class Type extends PackageMember {
	boolean ^abstract
	op Type getOriginType() {
		return this;
	}
	
	refers Type[] superTypes
	contains TypeConstraint[] constraint
	
	op String toString() {
		return name;
	}
}
class TypeConstraint {
	Object value
}
class PrimitiveType extends Type, Exportable {
	op String toString() {
		return super.toString();
	}
}
class ComplexType extends Type, GenericElement {
	contains Declaration[] features
	
	op Declaration[] getAllFeatures() {
		val features = new BasicEList<Declaration>();
		collectFeatures(this, features, new HashSet<Type>());
		return features;
	}
	
	op void collectFeatures(Type tpe, Declaration[] features, Object _visited) {
		val visited = _visited as Set<Type>;
		if (tpe === null || visited.contains(tpe))
			return;
		if (tpe instanceof ComplexType) {
			for (Type superType : tpe.getSuperTypes()) {
				collectFeatures(superType, features, visited);
			}
			features.addAll(tpe.getFeatures());
		}
		visited.add(tpe);
	}
	
}
class GenericElement extends NamedElement {
	contains TypeParameter[] typeParameters
}
class TypeParameter extends Type {
	refers Type bound
}
class Declaration extends TypedElement, NamedElement, PackageMember {
	
}
abstract class TypedElement {
	contains TypeSpecifier typeSpecifier
	
	op Type getType() {
		if (getTypeSpecifier() !== null) {
			return getTypeSpecifier().getType();
		}
		return null;
	}
}
class Operation extends Declaration, GenericElement {
	contains Parameter[] parameters opposite owningOperation
}
class Parameter extends TypedElement, NamedElement {
	container Operation owningOperation opposite parameters
	boolean optional
}
class Enumerator extends Declaration {
	container EnumerationType owningEnumeration opposite enumerator
}
class EnumerationType extends PrimitiveType {
	contains Enumerator[] enumerator opposite owningEnumeration
	op String toString() {
		return super.toString()
	}
}

abstract class GeneratedElement {
	/**
	 * The fully-qualified class name of the generator class. 
	 */
	String generator
	
	/**
	 * The optional fully-qualified name of the validator class.
	 */
	String validator
	
	/**
	 * The optional fully-qualified name of the element size inferrer class.
	 */
	String sizeInferrer
}


interface HasAccessors {
	/**
	 * caution: this is only the type from the parsed model, not neccessarily the inferred type. Use with caution for type inferrence.
	 */
	op Type[] accessorsTypes()
}

class Exportable {
	boolean exported
}

class ExceptionTypeDeclaration extends Type, Exportable {
}

class NativeType extends PrimitiveType, Exportable {
	String aliasOf
	String header
	
	op String getCName() {
		if(aliasOf === null) {
			return name
		} else {
			return aliasOf
		}
	}
	
	op String toString() {
		return name
	}
}

class StructureType extends ComplexType, HasAccessors, Exportable {
	contains Parameter[] parameters
	op Type[] accessorsTypes() {
		return parameters.map[it.typeSpecifier.^type];
	}
	
	op String toString() {
		super.toString
	}
}

class GeneratedType extends ComplexType, GeneratedElement, Exportable {
	contains Operation constructor
	
	op String toString() {
		super.toString
	}
}

class PackageAssociation {
	String name
}

class ImportStatement {
	String importedNamespace
}
 

class SumType extends ComplexType, Exportable {
	// I would use features, but if I want to have SumAlternative as a ComplexType (which it is), then I can't make it a Declaration as well
	contains SumAlternative[] alternatives
	
	op String toString() {
		return super.toString();
	}
}
interface SumAlternative extends ComplexType, HasAccessors {
	op Type realType() {
		return this;
	}
}
class Singleton extends SumAlternative {
	op Type[] accessorsTypes() {
		return #[].asEList;
	}
}
class AnonymousProductType extends SumAlternative {
	contains TypeSpecifier[] typeSpecifiers 
	op Type realType() {
		if(typeSpecifiers.length == 1) {
			return typeSpecifiers.get(0).^type;
		}
		else {
			return this;
		}
	}
	op Type[] accessorsTypes() {
		// need to duplicate functionality, since calling realType and deferring to that ones accessor types would create infinite recursion if it returns this
		// could check with == this, but that would be more confusing I think
		if(typeSpecifiers.length == 1) {
			val realType = typeSpecifiers.get(0).^type;
			if(realType instanceof HasAccessors) {
				return realType.accessorsTypes;
			}
		}
		return typeSpecifiers.map[it.^type];
	}
}
class NamedProductType extends SumAlternative, HasAccessors {
	contains Parameter[] parameters
	// always return parameter types, since we never embed
	op Type[] accessorsTypes() {
		return parameters.map[it.typeSpecifier.^type];
	}
}
class ProductMember extends Parameter { }

class TypeAlias extends Type, Declaration {
	
	op Type getOriginType() {
		val baseType = getType();
		if (baseType instanceof TypeAlias && baseType != this) {
			return baseType.getOriginType();			
		}
		return baseType;
	}
	
}

class Property extends Declaration {
	boolean const
	boolean external
	boolean ^readonly
}

class Event extends Declaration {
	
}
