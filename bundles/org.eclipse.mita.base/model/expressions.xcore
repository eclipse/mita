@GenModel(copyrightText="generated by Xtext 2.13.0", operationReflection="false", modelDirectory="/org.eclipse.mita.base/emf-gen")
package org.eclipse.mita.base.expressions

/********************************************************************************
 * Copyright (c) 2018 TypeFox GmbH.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * Contributors:
 *    TypeFox GmbH - initial contribution
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/

import org.eclipse.emf.ecore.EEnumerator
import org.eclipse.emf.ecore.EObject
import org.eclipse.mita.base.types.Type
import org.eclipse.mita.base.types.NamedElement
import org.eclipse.mita.base.types.Parameter
import org.eclipse.mita.base.types.ParameterWithDefaultValue
import org.eclipse.mita.base.types.Operation
import org.eclipse.mita.base.types.Expression
import org.eclipse.mita.base.expressions.util.ArgumentSorter
import org.eclipse.xtext.nodemodel.util.NodeModelUtils

class GeneratedTypeParameter extends ParameterWithDefaultValue {
	boolean ^static
}

class ExpressionStatement extends AbstractStatement {
	contains Expression expression
	op String toString() {
		return expression.toString + ";";
	}
}

class AssignmentExpression extends Expression {
	contains Expression varRef
	AssignmentOperator operator
	contains Expression expression
	op String toString() {
		return varRef.toString + " " + operator + " " + expression.toString
	}
}

abstract class BinaryExpression extends Expression {
	contains Expression leftOperand
	op EEnumerator getOperator()
	contains Expression rightOperand
	op String toString() {
		return leftOperand + " " + operator + " " + rightOperand;
	} 
}
abstract class UnaryExpression extends Expression {
	op EEnumerator getOperator()
	contains Expression operand
	op String toString() {
		return operator.toString + operand.toString
	}
}
abstract class ArgumentExpression extends Expression {
	op Expression[] getArgs()
	op Expression[] getExpressions()
	contains Argument[] arguments
}

abstract class Literal {
}
class BoolLiteral extends Literal {
	boolean value
	op String toString() {
		return "b»" + value
	}
}
class IntLiteral extends Literal {
	long value
	op String toString() {
		return "i»" + value
	}
}
class DoubleLiteral extends Literal {
	double value
	op String toString() {
		return "d»" + value
	}
}
class FloatLiteral extends Literal {
	float value
	op String toString() {
		return "f»" + value
	}
}
class HexLiteral extends IntLiteral {
	op String toString() {
		return "x»" + Long.toHexString(value)
	}
}
class BinaryLiteral extends IntLiteral {
	op String toString() {
		return "b»" + Long.toBinaryString(value)
	}
}
class StringLiteral extends Literal {
	String value
	op String toString() {
		return "s»" + '"' + value + '"'
	}
}
class NullLiteral extends Literal {
}

enum AssignmentOperator {
	assign as "=" = 0
	multAssign as "*=" = 1
	divAssign as "/=" = 2
	modAssign as "%=" = 3
	addAssign as "+=" = 4
	subAssign as "-=" = 5
	leftShiftAssign as "<<=" = 6
	rightShiftAssign as ">>=" = 7
	andAssign as "&=" = 8
	xorAssign as "^=" = 9
	orAssign as "|=" = 10
}
enum ShiftOperator {
	left as "<<" = 0
	right as ">>" = 1
}
enum AdditiveOperator {
	plus as "+" = 0
	minus as "-" = 1
}
enum MultiplicativeOperator {
	mul as "*" = 0
	div as "/" = 1
	mod as "%" = 2
}
enum UnaryOperator {
	positive as "+" = 0
	negative as "-" = 1
	complement as "~" = 2
}
enum RelationalOperator {
	smaller as "<" = 0
	smallerEqual as "<=" = 1
	greater as ">" = 2
	greaterEqual as ">=" = 3
	equals as "==" = 4
	notEquals as "!=" = 5
}
enum LogicalOperator {
	and as "&&" = 0
	or as "||" = 1
	not as "!" = 2
}
enum BitwiseOperator {
	xor as "^" = 0
	and as "&" = 1
	or as "|" = 2
}
enum PostFixOperator {
	increment as "++" = 0
	decrement as "--" = 1
}

abstract class AbstractStatement { }

class ConditionalExpression extends Expression {
	contains Expression condition
	contains Expression trueCase
	contains Expression falseCase
	op String toString() {
		return condition + " ? " + trueCase + " : " + falseCase;	
	}
}
class LogicalOrExpression extends BinaryExpression {
	op EEnumerator getOperator() {
		return LogicalOperator.OR
	}
	op String toString() {
		return super.toString;
	}
}
class LogicalAndExpression extends BinaryExpression { 
	op EEnumerator getOperator() {
		return LogicalOperator.AND
	}
	op String toString() {
		return super.toString;
	}
}
class LogicalNotExpression extends UnaryExpression {
	op EEnumerator getOperator() {
		return LogicalOperator.NOT
	}
	op String toString() {
		return super.toString;
	} 
}
class BitwiseXorExpression extends BinaryExpression {
	op EEnumerator getOperator() {
		return BitwiseOperator.XOR
	}  
	op String toString() {
		return super.toString;
	}
}
class BitwiseOrExpression extends BinaryExpression {
	op EEnumerator getOperator() {
		return BitwiseOperator.OR
	} 
	op String toString() {
		return super.toString;
	}
}
class BitwiseAndExpression extends BinaryExpression {
	op EEnumerator getOperator() {
		return BitwiseOperator.AND
	} 
	op String toString() {
		return super.toString;
	}
}
class LogicalRelationExpression extends BinaryExpression {
	RelationalOperator operator
	op String toString() {
		return super.toString;
	} 
}
class ShiftExpression extends BinaryExpression {
	ShiftOperator operator 
	op String toString() {
		return super.toString;
	}
}
class NumericalAddSubtractExpression extends BinaryExpression {
	AdditiveOperator operator 
	op String toString() {
		return super.toString;
	}
}
class NumericalMultiplyDivideExpression extends BinaryExpression {
	MultiplicativeOperator operator 
	op String toString() {
		return super.toString;
	}
}
class NumericalUnaryExpression extends UnaryExpression {
	UnaryOperator operator 
	op String toString() {
		return super.toString;
	}
}
class PostFixUnaryExpression extends UnaryExpression {
	PostFixOperator operator
	op String toString() {
		return operand.toString + operator.toString;
	}
}

class PrimitiveValueExpression extends Expression {
	contains Literal value
	op String toString() {
		return "prim»" + value;
	}
}
abstract class ArrayAccessOrOperationCallExpression {
	boolean operationCall
	contains Expression[] arraySelector
	boolean arrayAccess
}
class ArrayAccessExpression extends Expression {
	contains Expression owner
	contains Expression arraySelector
	op String toString() {
		return owner + "[" + arraySelector + "]"
	}
}

class ValueRange extends Expression {
	contains Expression lowerBound
	contains Expression upperBound
	op String toString() {
		return (lowerBound?.toString ?: "") + ":" + (upperBound?.toString ?: "")
	}
}

class FeatureCall extends ElementReferenceExpression {
	op String toString() {
		return arguments.head?.value + "." + refText + (if(operationCall) "(" + arguments.tail.join(", ") + ")" else "");
	}
}

class FeatureCallWithoutFeature extends FeatureCall {
	op String toString() {	
		return "<auto>." + refText + (if(operationCall) "(" + arguments.join(", ") + ")" else "");
	}
}

class ElementReferenceExpression extends ArgumentExpression, ArrayAccessOrOperationCallExpression {
	refers EObject reference
	
	op Expression[] getExpressions() {
		val ref = eGet(ExpressionsPackage.eINSTANCE.elementReferenceExpression_Reference, false)
		if (ref instanceof Operation) {
			return ArgumentSorter.getOrderedExpressions(getArguments(), ref);
		} else {
			return arguments.map[value];
		}
	}
	
	op String getRefText() {
		val ref = eGet(ExpressionsPackage.eINSTANCE.elementReferenceExpression_Reference, false)
		
		var refText = if(ref instanceof NamedElement) {
			ref.name;
		} else if(ref !== null && ref instanceof EObject && !(ref as EObject).eIsProxy) {
			ref.toString();	
		}
		refText = refText ?: NodeModelUtils.findNodesForFeature(this, ExpressionsPackage.eINSTANCE.elementReferenceExpression_Reference).head?.text
		refText = refText ?: "<null>"
		
		return refText;
	}
	
	op String toString() {		
		return refText + (if(!arguments.empty) "(" + arguments.join(", ") + ")" else "")
	}
}
class ParenthesizedExpression extends Expression {
	contains Expression expression
}
class TypeCastExpression extends Expression {
	contains Expression operand
	refers Type ^type
	op String toString() {
		val ref = eGet(ExpressionsPackage.eINSTANCE.typeCastExpression_Type, false)
		
		var refText = ref?.toString()
		refText = refText ?: NodeModelUtils.findNodesForFeature(this, ExpressionsPackage.eINSTANCE.typeCastExpression_Type).head?.text
		refText = refText ?: "<null>"
		
		return operand + " as " + refText;
	}
}
class Argument extends Expression {
	refers Parameter parameter
	contains Expression value
	
	op String toString() {
		val param = eGet(ExpressionsPackage.eINSTANCE.argument_Parameter, false)
		
		var refText = param?.toString()
		refText = refText ?: NodeModelUtils.findNodesForFeature(this, ExpressionsPackage.eINSTANCE.argument_Parameter).head?.text
		refText = refText ?: "<null>"
		
		return (if(refText !== null) refText + "=" else "") + value;
	}
}

