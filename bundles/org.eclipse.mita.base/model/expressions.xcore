@GenModel(copyrightText="generated by Xtext 2.13.0", operationReflection="false", modelDirectory="/org.eclipse.mita.base/emf-gen")
package org.eclipse.mita.base.expressions

/********************************************************************************
 * Copyright (c) 2018 TypeFox GmbH.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * Contributors:
 *    TypeFox GmbH - initial contribution
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/

import org.eclipse.emf.ecore.EEnumerator
import org.eclipse.emf.ecore.EObject
import org.eclipse.mita.base.types.Type
import org.eclipse.mita.base.types.Parameter
import org.eclipse.mita.base.types.Operation
import org.eclipse.emf.common.util.EList
import org.eclipse.mita.base.expressions.util.ArgumentSorter
import org.eclipse.emf.common.util.BasicEList


class GeneratedTypeParameter extends Parameter {
	boolean ^static
	contains Expression value
}

abstract class Expression {
}

abstract class BinaryExpression extends Expression {
	contains Expression leftOperand
	op EEnumerator getOperator()
	contains Expression rightOperand
}
abstract class UnaryExpression extends Expression {
	op EEnumerator getOperator()
	contains Expression operand
}
abstract class ArgumentExpression extends Expression {
	op Expression[] getArgs()
	op Expression[] getExpressions()
	contains Argument[] arguments
}

abstract class Literal {
}
class BoolLiteral extends Literal {
	boolean value
}
class IntLiteral extends Literal {
	int value
}
class DoubleLiteral extends Literal {
	double value
}
class FloatLiteral extends Literal {
	float value
}
class HexLiteral extends IntLiteral {
}
class BinaryLiteral extends IntLiteral {
}
class StringLiteral extends Literal {
	String value
}
class NullLiteral extends Literal {
}

enum AssignmentOperator {
	assign as "=" = 0
	multAssign as "*=" = 1
	divAssign as "/=" = 2
	modAssign as "%=" = 3
	addAssign as "+=" = 4
	subAssign as "-=" = 5
	leftShiftAssign as "<<=" = 6
	rightShiftAssign as ">>=" = 7
	andAssign as "&=" = 8
	xorAssign as "^=" = 9
	orAssign as "|=" = 10
}
enum ShiftOperator {
	left as "<<" = 0
	right as ">>" = 1
}
enum AdditiveOperator {
	plus as "+" = 0
	minus as "-" = 1
}
enum MultiplicativeOperator {
	mul as "*" = 0
	div as "/" = 1
	mod as "%" = 2
}
enum UnaryOperator {
	positive as "+" = 0
	negative as "-" = 1
	complement as "~" = 2
}
enum RelationalOperator {
	smaller as "<" = 0
	smallerEqual as "<=" = 1
	greater as ">" = 2
	greaterEqual as ">=" = 3
	equals as "==" = 4
	notEquals as "!=" = 5
}
enum LogicalOperator {
	and as "&&" = 0
	or as "||" = 1
	not as "!" = 2
}
enum BitwiseOperator {
	xor as "^" = 0
	and as "&" = 1
	or as "|" = 2
}
enum PostFixOperator {
	increment as "++" = 0
	decrement as "--" = 1
}

class AssignmentExpression extends Expression {
	contains Expression varRef
	AssignmentOperator operator
	contains Expression expression
}
class ConditionalExpression extends Expression {
	contains Expression condition
	contains Expression trueCase
	contains Expression falseCase
}
class LogicalOrExpression extends BinaryExpression {
	op EEnumerator getOperator() {
		return LogicalOperator.OR
	}
}
class LogicalAndExpression extends BinaryExpression { 
	op EEnumerator getOperator() {
		return LogicalOperator.AND
	}
}
class LogicalNotExpression extends UnaryExpression {
	op EEnumerator getOperator() {
		return LogicalOperator.NOT
	} 
}
class BitwiseXorExpression extends BinaryExpression {
	op EEnumerator getOperator() {
		return BitwiseOperator.XOR
	}  
}
class BitwiseOrExpression extends BinaryExpression {
	op EEnumerator getOperator() {
		return BitwiseOperator.OR
	} 
}
class BitwiseAndExpression extends BinaryExpression {
	op EEnumerator getOperator() {
		return BitwiseOperator.AND
	} 
}
class LogicalRelationExpression extends BinaryExpression {
	RelationalOperator operator 
}
class ShiftExpression extends BinaryExpression {
	ShiftOperator operator 
}
class NumericalAddSubtractExpression extends BinaryExpression {
	AdditiveOperator operator 
}
class NumericalMultiplyDivideExpression extends BinaryExpression {
	MultiplicativeOperator operator 
}
class NumericalUnaryExpression extends UnaryExpression {
	UnaryOperator operator 
}
class PostFixUnaryExpression extends UnaryExpression {
	PostFixOperator operator
}

class PrimitiveValueExpression extends Expression {
	contains Literal value
}
abstract class ArrayAccessOrOperationCallExpression {
	boolean operationCall
	contains Expression[] arraySelector
	boolean arrayAccess
}
class FeatureCall extends ArgumentExpression, ArrayAccessOrOperationCallExpression {
	contains Expression owner
	refers EObject feature
	
	op Expression[] getExpressions() {
		if (feature instanceof Operation) {
			return ArgumentSorter.getOrderedExpressions(getArguments(), feature as Operation);
		} else {
			return new BasicEList<Expression>();
		}
	}
}
class ElementReferenceExpression extends ArgumentExpression, ArrayAccessOrOperationCallExpression {
	refers EObject reference
	
	op Expression[] getExpressions() {
		if (reference instanceof Operation) {
			return ArgumentSorter.getOrderedExpressions(getArguments(), reference as Operation);
		} else {
			return new BasicEList<Expression>();
		}
	}
}
class ParenthesizedExpression extends Expression {
	contains Expression expression
}
class TypeCastExpression extends Expression {
	contains Expression operand
	refers Type ^type
}
class Argument {
	refers Parameter parameter
	contains Expression value
}

