/********************************************************************************
 * Copyright (c) 2017, 2018 Bosch Connected Devices and Solutions GmbH.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * Contributors:
 *    Bosch Connected Devices and Solutions GmbH - initial contribution
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/

grammar org.eclipse.mita.base.TypeDsl hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "org.eclipse.mita.base.types"
import "org.eclipse.mita.base.expressions"

TypeRoot returns Package:
	{Package}
	(member+=TypeDeclaration)* 
;

TypeDeclaration returns Type:
	(NativeTypeDeclaration | StructureTypeDeclaration | ExceptionTypeDeclaration | EnumerationDeclaration | GeneratedType | SumType) 
;

NativeTypeDeclaration returns NativeType:
	(exported?='export')? 
	'native-type' name=ID
	('alias-of' aliasOf=ID)?
	('header' header=STRING)?
;

EnumerationDeclaration returns SumType:
	{SumType}
	typeKind=TypeKind
	(exported?='export')?
	'enum' name=ID '{' alternatives += Enumerator (',' alternatives += Enumerator)*
	'}';

Enumerator returns Singleton:
	name=ID constructor=SumSubTypeConstructor;

NullTypeSpecifier returns NullTypeSpecifier:
	{NullTypeSpecifier}
;

StructureTypeDeclaration returns ComplexType: 
	{StructureType}
	constructor=TypeConstructor
	(exported?='export')?
	'struct' name=ID '{' (parameters+=StructureField)+ '}'
;

TypeConstructor returns TypeConstructor:
	{TypeConstructor}
;
TypeAccessor returns TypeAccessor:
	{TypeAccessor}
;

StructureField returns StructuralParameter: 
	accessor = TypeAccessor
	'var' name=ID ':' typeSpecifier=TypeSpecifier ';'
;

ExceptionTypeDeclaration: 
	(exported?='export')?
	'exception' name=ID ';'
;

GeneratedType returns GeneratedType:
	{GeneratedType} 
	(exported?='export')?
	'generated' 'type' name=ID ('<' (typeParameters+=TypeParameter) (',' typeParameters+=TypeParameter)* '>')?
		'generator' generator=STRING
		'size-inferrer' sizeInferrer=STRING
		('validator' validator=STRING)?
		constructor = GeneratedTypeConstructor
	';'
;

GeneratedTypeConstructor returns GeneratedTypeConstructor:
	{GeneratedTypeConstructor}
	'constructor' name='con' '(' (parameters+=GeneratedTypeParameter (',' parameters+=GeneratedTypeParameter)*)? ')' 
;

GeneratedTypeParameter returns GeneratedTypeParameter:
	{GeneratedTypeParameter}
	name=ID ':' (static?='static')? typeSpecifier=TypeSpecifier (optional?='=' defaultValue=Expression)?
;

TypeParameter returns TypeParameter:
	(InstanceTypeParameter | RawTypeParameter)
;
RawTypeParameter returns RawTypeParameter:
	{RawTypeParameter}
	// since Invariant is the first=default value of Variance this assigns invariance on no match
	//(variance=Variance)?
	name=ID 
;
InstanceTypeParameter returns InstanceTypeParameter:
	{InstanceTypeParameter}
	// since Invariant is the first=default value of Variance this assigns invariance on no match
	//(variance=Variance)? 
	name=ID 'is' ofType=[Type] 
;

TypeKind returns TypeKind:
	{TypeKind}
;

SumType returns SumType:
	{SumType}
	typeKind=TypeKind
	(exported?='export')?
	('alt' | 'alternative') name = ID '{' alternatives += SumAlternative ('|' alternatives += SumAlternative)* '}'
;	

SumAlternative returns SumAlternative:
	( AnonymousProductType
	| NamedProductType 
	| Singleton
	)
;

SumSubTypeConstructor returns SumSubTypeConstructor:
	{SumSubTypeConstructor}
;

AnonymousProductTypeImportingConstructor returns AnonymousProductTypeImportingConstructor:
	{AnonymousProductTypeImportingConstructor}
;

Singleton returns Singleton:
	constructor=SumSubTypeConstructor
	name=ID
;
AnonymousProductType returns AnonymousProductType: 
	{AnonymousProductType}
	constructor=SumSubTypeConstructor
	name=ID ':' (
		  typeSpecifiers+=TypeSpecifier (',' typeSpecifiers+=TypeSpecifier)*  /* ((',' typeSpecifiers+=TypeSpecifier)+ | (importingConstructor=AnonymousProductTypeImportingConstructor)) */
	)
;
NamedProductType returns NamedProductType:
	{NamedProductType}
	constructor=SumSubTypeConstructor
	name=ID ':' '{' parameters+=ProductMember (',' parameters+=ProductMember)* '}'
;

ProductMember returns ProductMember: 
	accessor = TypeAccessor
	name=ID ':' typeSpecifier=TypeSpecifier
;


/**
 * BELOW THIS LINE
 * 
 * Copyright (c) 2010 - 2015 committers of YAKINDU and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * Contributors:
 * 	committers of YAKINDU - initial API and implementation
 *  Bosch Connected Devices and Solutions GmbH - modifications
 * 
 */
Expression:
	ConditionalExpression;
	
AssignmentExpression returns Expression:
	ConditionalExpression ({AssignmentExpression.varRef=current} operator=AssignmentOperator expression=Expression)?
;

ConditionalExpression returns Expression:
	LogicalOrExpression ({ConditionalExpression.condition=current} '?' trueCase=LogicalOrExpression ':'
	falseCase=LogicalOrExpression)?;

LogicalOrExpression returns Expression:
	LogicalAndExpression ({LogicalOrExpression.leftOperand=current} LogicalOrOperator
	rightOperand=LogicalAndExpression)*;

LogicalAndExpression returns Expression:
	LogicalNotExpression ({LogicalAndExpression.leftOperand=current}
	LogicalAndOperator rightOperand=LogicalNotExpression)*;

LogicalNotExpression returns Expression:
	BitwiseXorExpression | {LogicalNotExpression} LogicalNotOperator
	operand=BitwiseXorExpression;

BitwiseXorExpression returns Expression:
	BitwiseOrExpression ({BitwiseXorExpression.leftOperand=current} BitwiseXOrOperator
	rightOperand=BitwiseOrExpression)*;

BitwiseOrExpression returns Expression:
	BitwiseAndExpression ({BitwiseOrExpression.leftOperand=current} BitwiseOrOperator
	rightOperand=BitwiseAndExpression)*;

BitwiseAndExpression returns Expression:
	LogicalRelationExpression ({BitwiseAndExpression.leftOperand=current} BitwiseAndOperator
	rightOperand=LogicalRelationExpression)*;

LogicalRelationExpression returns Expression:
	ShiftExpression
	({LogicalRelationExpression.leftOperand=current} operator=RelationalOperator
	rightOperand=ShiftExpression)*;

ShiftExpression returns Expression:
	NumericalAddSubtractExpression ({ShiftExpression.leftOperand=current} operator=ShiftOperator
	rightOperand=NumericalAddSubtractExpression)*;

NumericalAddSubtractExpression returns Expression:
	NumericalMultiplyDivideExpression
	=>({NumericalAddSubtractExpression.leftOperand=current}
	operator=AdditiveOperator
	rightOperand=NumericalMultiplyDivideExpression)*;

NumericalMultiplyDivideExpression returns Expression:
	NumericalUnaryExpression
	=>({NumericalMultiplyDivideExpression.leftOperand=current}
	operator=MultiplicativeOperator
	rightOperand=NumericalUnaryExpression)*;

NumericalUnaryExpression returns Expression:
	PostFixUnaryExpression | {NumericalUnaryExpression} operator=UnaryOperator operand=PostFixUnaryExpression;

PostFixUnaryExpression returns Expression:
	TypeCastExpression ({PostFixUnaryExpression.operand=current} operator=PostFixOperator)*;

TypeCastExpression returns Expression:
	PrimaryExpression (({TypeCastExpression.operand=current} 'as') type=[Type|QID])*;

PrimaryExpression returns Expression:
	PrimitiveValueExpression
	| FeatureCall;

PrimitiveValueExpression returns Expression:
	{PrimitiveValueExpression} value=Literal;

TypeExpression returns Expression:
	  ({NaryTypeAddition} values+=ValueOrSpecifier ('+' values+=ValueOrSpecifier)+)
	| IntExpression
;

ValueOrSpecifier returns Literal:
	IntLiteral | TypeReferenceLiteral
;

IntExpression returns Expression:
	{PrimitiveValueExpression} value=IntLiteral
;

TypeReferenceLiteral returns TypeReferenceLiteral:
	type=[Type]
;

arraySelector returns Expression:
	  Expression ({ValueRange.lowerBound=current} ':' (upperBound=Expression)?)?
	| ({ValueRange} ':' (upperBound=Expression)?)
;

FeatureCallWithoutFeature returns Expression:
	  ({FeatureCallWithoutFeature} operationCall?='.' reference=[ecore::EObject] (=> '('(arguments+=Argument (',' arguments+=Argument)*)?')')?)
;

FeatureCall returns Expression:
	FeatureCallWithoutFeature |
    (ElementReferenceExpression | ParenthesizedExpression) (
	      ({Argument.value=current} {FeatureCall.arguments+=current} operationCall?='.' reference=[ecore::EObject] (=> '('(arguments+=Argument (',' arguments+=Argument)*)?')')?)
		| ({ArrayAccessExpression.owner=current} '[' (arraySelector=arraySelector) ']')
    )*
;

ElementReferenceExpression returns Expression:
	{ElementReferenceExpression} reference=[ecore::EObject|ID]
	(=> operationCall?='('	(arguments+=Argument (',' arguments+=Argument)*)?	')' )?;

Argument returns Argument:
	(parameter=[Parameter] '=')?  value=ConditionalExpression
;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

TypeSpecifierArgument returns PresentTypeSpecifier:
	TypeExpressionSpecifier | TypeSpecifier | TypeHole
;

TypeHole returns TypeHole:
	{TypeHole}
	HOLE
;

TypeExpressionSpecifier returns TypeExpressionSpecifier:
	value=TypeExpression
;

TypeSpecifier returns TypeReferenceSpecifier:
	{TypeReferenceSpecifier} 
	(referenceModifiers+=('&' | LogicalAndOperator))* 
	type=[Type|QID] 
	('<' (typeArguments+=TypeSpecifierArgument (',' typeArguments+=TypeSpecifierArgument)* '>'))? (optional?="?")?;

InterpolatedStringLiteral returns InterpolatedStringLiteral: 
	{InterpolatedStringLiteral}
	'`' ((=>'${' content+=ConditionalExpression '}') | (text+=(ID|ReservedKeywords|ReservedSymbols|STRING|WS|IntAsString)))* '`'
;

Literal:
	BoolLiteral | HexLiteral | BinaryLiteral | IntLiteral | DoubleLiteral | FloatLiteral | StringLiteral;

BoolLiteral:
	{BoolLiteral} value=BOOL;

IntLiteral:
	{IntLiteral} value=LONG;

DoubleLiteral:
	{DoubleLiteral} value=DOUBLE;

FloatLiteral:
	{FloatLiteral} value=FLOAT;

HexLiteral:
	{HexLiteral} value=HEX;

BinaryLiteral:
	{BinaryLiteral} value=BINARY;

StringLiteral:
	{StringLiteral} value=STRING;

LogicalAndOperator:
	'&&';

LogicalOrOperator:
	'||';

LogicalNotOperator:
	'!';

BitwiseXOrOperator:
	'^';

BitwiseOrOperator:
	'|';

BitwiseAndOperator:
	'&';

enum Variance:
	Covariant | Contravariant;

enum PostFixOperator:
	increment="++" | decrement="--";

enum AssignmentOperator:
	assign='='
	| multAssign='*='
	| divAssign='/='
	| modAssign='%='
	| addAssign='+='
	| subAssign='-='
	| leftShiftAssign='<<='
	| rightShiftAssign='>>='
	| andAssign='&='
	| xorAssign='^='
	| orAssign='|=';

enum ShiftOperator:
	left='<<'
	| right='>>';

enum AdditiveOperator:
	plus='+' | minus='-';

enum MultiplicativeOperator:
	mul='*' | div='/' | mod='%';

enum UnaryOperator:
	positive='+' | negative='-' | complement='~';

enum RelationalOperator:
	smaller='<' | smallerEqual='<=' | greater='>' | greaterEqual='>=' |
	equals='==' | notEquals='!=';

terminal BOOL returns ecore::EBoolean:
	'true' | 'false';

terminal HEX returns ecore::ELong:
	('0') ('x' | 'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+;

terminal BINARY returns ecore::ELong: 
	('0')('b' | 'B') ('0'|'1')+
;
terminal DOUBLE returns ecore::EDouble:
	(LONG '.' LONG) ('e' ('-' | '+') LONG)? ('d' | 'D')?;

terminal FLOAT returns ecore::EFloat:
	(LONG '.' LONG) ('e' ('-' | '+') LONG)? ('f' | 'F')?;

QID:
	ID ('.' ID)*;
	
IntAsString returns ecore::EString: LONG;

ReservedKeywords:
	'alias-of' |
	'alt' |
	'alternative' |
	'as' |
	'catch' |
	'checked' |
	'constructor' |
	'do' |
	'else' |
	'enum' |
	'every' |
	'exception' |
	'export' |
	'extends' |
	'finally' |
	'fn' |
	'for' |
	'function' |
	'generated' |
	'generator' |
	'header' |
	'hour' |
	'hours' |
	'if' |
	'in' |
	'import' |
	'is' |
	'isother' |
	'let' |
	'millisecond' |
	'milliseconds' |
	'minute' |
	'minutes' |
	'native' |
	'native-type' |
	'new' |
	'package' |
	'return' |
	'second' |
	'seconds' |
	'setup' |
	'size-inferrer' |
	'static' |
	'struct' |
	'subtype-of' |
	'throw' |
	'try' |
	'type' |
	'unchecked' |
	'validator' |
	'var' |
	'where' |
	'while'
;

ReservedSymbols:
	'{' | '}' |
	',' | ';' |
	':' | '.' |
	'(' | ')' |
	'[' | ']' |
	'+' | '-' |
	'*' | '/' |
	'%' | '\\'| 
	'&&' | '||' |
	'&' | '|' |
	'=' | '==' |
	'!' | '<' | 
	'>' | '<=' |
	'>=' | '!=' |
	HOLE
;


/*******************************************************************************
 * BELOW THIS LINE
 * 
 * Copyright (c) 2008 itemis AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/

// _ only if followed by something
terminal ID: '^'? (('a'..'z'|'A'..'Z') | (('a'..'z'|'A'..'Z' | '_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+));
terminal HOLE: '_';
terminal LONG returns ecore::ELong: ('0'..'9')+;
terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
		;
terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS         : (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;

